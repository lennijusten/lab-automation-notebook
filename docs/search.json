[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi there. I’m Lenni, a first year master’s student at the MIT Media Lab. This website is currently serving as my final project lab notebook for the 2024 How to Grow (Almost) Anything course, although it may accompany me beyond the course.\nThe general topics I expect to cover are lab automation for biology and AI-assisted science with language models and agent scaffolding."
  },
  {
    "objectID": "posts/pylabrobot-or-opentrons/index.html",
    "href": "posts/pylabrobot-or-opentrons/index.html",
    "title": "PyLabRobot or Opentrons API?",
    "section": "",
    "text": "A few days ago I ran into a bug that prevented me from running PyLabRobot (PLR) protocols on the Opentrons robot. The issue was ultimately resolved by updating PLR and opentrons-python-api – a python wrapper around the Opentrons HTTP API used by PLR. But it took long enough for me to figure this out that I looked into using the Opentrons python API.\nThere are two main reasons I see for using the Opentrons python API over PLR for my LLM automation assistant project:\n\nOpentrons hardware is always going to be supported by the opentrons python package, whereas integrating it into PLR will require writing code to integrate the labware and the HTTP commands used to control various modules. This is some of what I’ve been working on in the last few days.\nThere’s a larger corpus of Opentrons protocols and documentation than PLR at this stage, which will make it easier to scaffold the LLM assistant.\n\nMy main complaint while exploring the Opentrons library (rather briefly I might add) is that the “out of the box” way to run experiments on Opentrons is to write a python file containing the entire protocol where you stick the commands you want to send to a robot in a run function, and then upload that python file to the Opentons app on your computer. Once you’ve uploaded the protocol, Rick tells me it gets sent to an onboard Rasberry Pie which converts your python into actual firmware level commands.\nIn this way, your protocol gets executed in a sort of linear, inflexible way. You have the option to pause the protcol and start over, but tweaking things means making an edit in your run function and then uploading the revised protocol to the Opentrons app where you then begin again. This is useful for sharing highly systemized protocols with other Opentrons users, where everything is controlled and the deck layout and hardware is largely the same was designated in the original protocol. But as I pointed out in my last post, protocol development feels like a very iterative process where you want to be able to execute single commands, let things fail, and build your protocol one part after another.\nMy main reason for preferring PyLabRobot was that this iterative development is baked into the whole library. You can use Jupyter Notebooks to write individual commands or code blocks and execute them one at a time on the Opentrons robot or any of the other platforms supported by PLR for that matter.\nAs it turns out, Opentrons also let you access some version of this feature by serving a Jupyter Notebook which you can connect to with you web browser. You can read their docs here. Essentially, you can call opentrons.execute around commands. I still need to verify this in lab.\nAnyways, if it turns out this works well with the Opentrons platform, there may be a better argument to switching my focus from PLR implementation to Opentrons. Of course, there are other benefits of PLR to consider, the main one being that whatever system I build to write/develop protocols will work much better on other robot platforms, like Hamiltons and Tecans."
  },
  {
    "objectID": "posts/serial-dilution/index.html",
    "href": "posts/serial-dilution/index.html",
    "title": "Ten-fold serial dilution",
    "section": "",
    "text": "Serial Dilution Workflow\nToday I spent around three hours in the Media Lab space and managed to set up a workflow for performing serial dilutions on the Opentrons robot. I chose to work on serial dilutions because they’re pretty straightforward from an automation perspective and seem like a good “easy” candidate for an LLM to attempt. In this entry, I’ll walk through the PyLabRobot implementation and comment on a few takeaways from today’s session.Serial dilutions are a fundamental technique used to systematically dilute a concentrated solution by creating a series of successive dilutions, each being a fixed ratio of the previous one. The two most common dilution factors are ten-fold (1:10) and two-fold (1:2). In a ten-fold serial dilution, each subsequent dilution is 10 times less concentrated than the previous one, while in a two-fold serial dilution, each subsequent dilution is 2 times less concentrated.\n\n\nSerial Dilution Background\nTen-fold serial dilutions are typically used when a large range of concentrations needs to be covered, such as in bacterial enumeration or viral titer determination. Two-fold serial dilutions are often used when a more precise concentration range is required, such as in ELISA assays for antibody titer determination.\nI won’t go into much more detail here about serial dilutions because there are many great resources like this one where you can learn more.\n\n\nLessons 1: Claude Understands Serial Dilutions\nVery early in the process, I asked Claude (Opus) to explain how the serial dilution would work given my lab setup. Claude helpfully outlined the steps I would need to take, and I based my implementation on those instructions. Later, when trying to recreate the behavior, Claude would sometimes accidentally provide me instructions for a 4-step dilution instead of a 5-step dilution (see example below), and once suggested adding more volume to a single well than was actually possible.\nLenni\nI want perform a simple 5-step 10-fold serial dilution on an Opentrons liquid handling robot. This example is more to\nhelp me understand the math and logic behind the process as opposed to achieving some experimental goal.\n\nGiven the following resources, walk me through the steps for performing the serial dilution.\n 1. A 360 uL 96-well plate\n 2. A beaker of water (dilutent)\n 3. A beaker of water + food coloring (my concentrated solution)\nClaude\nGreat! Let's walk through the steps for performing a simple 5-step 10-fold serial dilution using an Opentrons liquid\nhandling robot. We'll use water as the diluent and water with food coloring as the concentrated solution.\n\nResources:\n1. A 360 µL 96-well plate\n2. A beaker of water (diluent)\n3. A beaker of water + food coloring (concentrated solution)\n\nSteps:\n1. Begin by adding 180 µL of water (diluent) to wells A2, A3, A4, and A5 of the 96-well plate using the Opentrons robot.\n2. Add 200 µL of the water + food coloring solution (concentrated solution) to well A1 of the 96-well plate.\n3. Transfer 20 µL of the solution from well A1 to well A2 using the Opentrons robot. Mix the contents of well A2 by\npipetting up and down a few times. This step creates a 1:10 dilution (10^-1) of the original solution.\n4. Transfer 20 µL of the diluted solution from well A2 to well A3. Mix the contents of well A3 by pipetting up and down\na few times. This step creates a 1:100 dilution (10^-2) of the original solution.\n5. Transfer 20 µL of the diluted solution from well A3 to well A4. Mix the contents of well A4 by pipetting up and down\na few times. This step creates a 1:1,000 dilution (10^-3) of the original solution.\n6. Transfer 20 µL of the diluted solution from well A4 to well A5. Mix the contents of well A5 by pipetting up and down\na few times. This step creates a 1:10,000 dilution (10^-4) of the original solution.\n\nAt the end of this process, you will have the following dilutions in your 96-well plate:\n* Well A1: Original concentrated solution\n* Well A2: 1:10 dilution (10^-1)\n* Well A3: 1:100 dilution (10^-2)\n* Well A4: 1:1,000 dilution (10^-3)\n* Well A5: 1:10,000 dilution (10^-4)\n\nThe math behind each dilution step is as follows:\n* Step 3: (20 µL of solution A1 + 180 µL of diluent) / 200 µL total volume = 1:10 dilution\n* Step 4: (20 µL of solution A2 + 180 µL of diluent) / 200 µL total volume = 1:100 dilution\n* Step 5: (20 µL of solution A3 + 180 µL of diluent) / 200 µL total volume = 1:1,000 dilution\n* Step 6: (20 µL of solution A4 + 180 µL of diluent) / 200 µL total volume = 1:10,000 dilution\n\nThe Opentrons robot can be programmed to perform these steps accurately and consistently, making the serial dilution\nprocess more efficient and reproducible.\nThanks Claude!\n\n\nImplementing the Serial Dilution on PyLabRobot\nFor this part, I didn’t use any LLMs outside of a few basic syntax questions where the LLM replaced Stack Overflow. Doing this “manually” was helpful to get more comfortable with PyLabRobot and also go end-to-end on a protocol implementation. I think that was actually the most important part, because I learned how protocol development occurs, and what it takes to “debug” your protocol in real-time. Using Jupyter notebooks is incredibly powerful for this because you can perform single commands and verify that each piece of your protocol works before moving onto the next part. Let’s look at the implementation and then I’ll discuss a few takeaways.\n\nBasic setup\nfrom pylabrobot.liquid_handling import LiquidHandler\nfrom pylabrobot.liquid_handling.backends import OpentronsBackend\nfrom pylabrobot.resources import OTDeck, Coordinate\n\nbackend = OpentronsBackend(host=\"xxx.xxx.xxx.xxx\", port=31950)\nlh = LiquidHandler(backend=backend, deck=OTDeck())\nawait lh.setup()\n\n\nDefine tip rack and plate resources\nfrom pylabrobot.resources.opentrons import *\n\ntips300 = opentrons_96_tiprack_300ul(\"tip_rack_300\")\nlh.deck.assign_child_at_slot(tips300, slot=10)\n\ntips20 = opentrons_96_tiprack_20ul(\"tip_rack_20\")\nlh.deck.assign_child_at_slot(tips20, slot=8)\n\nwell_plate = corning_96_wellplate_360ul_flat(\"96_wellplate_360ul_flat\")  # well volume is 400 uL MAX. Probably use 200-300 uL.\nlh.deck.assign_child_at_slot(well_plate, slot=7)\n\n\nDefine custom beaker resources with dye solution and dilutent\nfrom pylabrobot.resources import Container, Coordinate\n\n# Define custom beaker resource with diluent\ndilutent_deck_slot = Container(name=\"dilutent_deck_parent\", size_x=127,size_y=86,size_z=0)  # Dimensions of a single slot on the Opentrons deck\ndilutent_beaker = Container(name='dilutent_beaker', size_x=40,size_y=40,size_z=10)  # Dimensions of the beaker represented as a 3-dimensional box\ndilutent_deck_slot.assign_child_resource(dilutent_beaker, Coordinate(x=43.5, y=23, z=0))  # Coordinates of the beaker with respect to the beaker_parent coordinate system\nlh.deck.assign_child_at_slot(dilutent_deck_slot, slot=1)\n\n# Define custom beaker resource with dye solution\ndye_deck_slot = Container(name=\"dye_deck_parent\", size_x=127,size_y=86,size_z=0)\ndye_beaker = Container(name='dye_beaker', size_x=25,size_y=24,size_z=10)\ndye_deck_slot.assign_child_resource(dye_beaker, Coordinate(x=43.5, y=23, z=0))\nlh.deck.assign_child_at_slot(dye_deck_slot, slot=2)\n\nlh.summary()\n  Deck: 624.3mm x 565.2mm\n  +-----------------+-----------------+-----------------+\n  |                 |                 |                 |\n  | 10: tip_rack... | 11: Empty       | 12: trash_co... |\n  |                 |                 |                 |\n  +-----------------+-----------------+-----------------+\n  |                 |                 |                 |\n  |  7: 96_wellp... |  8: tip_rack... |  9: Empty       |\n  |                 |                 |                 |\n  +-----------------+-----------------+-----------------+\n  |                 |                 |                 |\n  |  4: Empty       |  5: Empty       |  6: Empty       |\n  |                 |                 |                 |\n  +-----------------+-----------------+-----------------+\n  |                 |                 |                 |\n  |  1: dilutent... |  2: dye_beak... |  3: Empty       |\n  |                 |                 |                 |\n  +-----------------+-----------------+-----------------\n\n\nLabeling wells\nLet’s label wells with their respective dilution factors for clarity.\ninitial = well_plate['A1']  # initial concentration\ndilution1 = well_plate['A2']  # 1:10 dilution\ndilution2 = well_plate['A3']  # 1:100 dilution\ndilution3 = well_plate['A4']  # 1:1000 dilution\ndilution4 = well_plate['A5']  # 1:10000 dilution\ndilution5 = well_plate['A6']  # 1:100000 dilution\ndilution_wells = [dilution1, dilution2, dilution3, dilution4, dilution5]\n\n\nTransferring liquids\nLet’s transfer 200 uL of the original dye-containing solution into the initial well.\nawait lh.pick_up_tips(tips300[f'A1'], offsets=[Coordinate(y=0.18, z=-6)]) # pick up a new tip\nawait lh.aspirate(dye_beaker,200, offsets=[Coordinate(z=8)]) # grab dye solution from beaker resource\nawait lh.dispense(initial, vols=200, offsets=[Coordinate(y=0.2)])\nawait lh.discard_tips()\nNext, we’ll transfer 180 uL of diluent into each of the dilution wells. We will reuse the pipette tip since we’re just transferring water and discard it at the end.\nawait lh.pick_up_tips(tips300[f'A2'], offsets=[Coordinate(y=0.18, z=-6)]) # pick up a new tip\n\nfor index, well in enumerate(dilution_wells):\n    await lh.aspirate(dilutent_beaker,180, offsets=[Coordinate(z=20)]) # grab diluent from beaker resource\n    await lh.dispense(well, vols=180, offsets=[Coordinate(y=0.2)])\n\nawait lh.discard_tips()\nNext, we’ll transfer 20 uL from the dye solution beaker into the dilution1 well, creating our 1:10 dilution. We’ll then take 20 uL from dilution1 and transfer it to the dilution2 well and so on, until we’ve performed all of our dilutions.\nawait lh.pick_up_tips(tips20[f'A1'], offsets=[Coordinate(z=-6)]) # pick up a new tip\nawait lh.aspirate(dye_beaker,20, offsets=[Coordinate(z=8)])  # get liquid from bacteria beaker\nawait lh.dispense(dilution1,20, offsets=[Coordinate(z=2)])  # aspirate to make 1:10 dilution\n\nfor i in range(len(dilution_wells) - 1):\n    source_well = dilution_wells[i]\n    destination_well = dilution_wells[i+1]\n\n    await lh.aspirate(source_well, 20, offsets=[Coordinate(z=-6.5)])\n    await lh.dispense(destination_well, 20, offsets=[Coordinate(z=2)])\n\nawait lh.discard_tips()\nVoilà. I tested the protocol and it (mostly) works (video available here). The main issue I saw with the current implementation is that when dispensing with the 20 uL pipette tip, a drop tends to form at the bottom of the tip that likes to hang on… unfortunately that drop represents about half the volume inside the pipette. This is probably an issue addressed somewhere, so I’ll need to read up on that. On a related note, I didn’t really do any mixing of the dilutions. I could have aspirated/dispensed a few times with the tip in the well. This would have both mixed the solution and ensured the drop made it into the well.\nOther improvements to consider:\n\nUse a multi-channel adapter for the OT to save time when transferring diluent (Thanks for making me aware of this, Alex K!)\nIf I was doing this for real, I should have discarded tips between each dilution step to avoid tracking in liquid from a different well. I avoided this to save time and tips.\n\n\n\n\nLesson 2: Iterative Protocol Development Is Your Friend\nWhen I was initially thinking about this project, I was somewhat naive in believing that LLMs would be able to one-shot large portions of protocols or entire protocols. That seems hard.\nDeveloping the protocol was an iterative process. Are the custom resources in the right spot on the deck? Is the tip going far enough into the beaker to actually pick up liquid? How deep does the 20 uL tip need to go into the 96-well plate to aspirate liquid? All of these questions that pop up are difficult to know, even when you have pretty good knowledge of the deck setup. Some trial and error is inherent in the process. The fact that you can execute single commands in a Jupyter notebook is really useful as it lets you iterate over a step.\nThe scenario below is hopefully illustrative of how a lot of the development happened.\n\nAlright… I need to get the robot to aspirate liquid from this beaker. I’ll define it on the deck and then actually put water in the beaker and put it on the deck. Now let’s try the aspirate step with a z coordinate z=40. Oops. Too high. Didn’t get any liquid but the API thinks I have liquid in the top. Okay, send a command to dispense the ghost liquid. Alright, how about z=20… okay, that worked. Dispense. Okay pick up a new tip. Shoot, I asked it to pick up a tip from an empty tip slot. Okay, put back the ghost tip and move out of the way so I can put a tip in there… So on and so forth.\n\nIn this kind of workflow where code meets the real world, iteration is your friend and it currently seems unrealistic to me for LLMs to do any kind of one-shot-and-run protocol development here. That said, if you can figure out and communicate to LLMs where their capabilities will be helpful, then I’m sure they can still be great automation assistants. For example, they could come up with the main skeleton script, helpfully divided into testable parts and flag places where testing needs to be done. Today was helpful to get me thinking more about how LLMs can fit into the lab automation workflow grounded in a more realistic understanding of protocol development."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome to my lab notebook",
    "section": "",
    "text": "Welcome! This post will eventually have some background on the project."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Lab automation notebook",
    "section": "",
    "text": "PyLabRobot or Opentrons API?\n\n\n\n\n\n\npylabrobot\n\n\nopentrons\n\n\ncode\n\n\n\n\n\n\n\n\n\nApr 22, 2024\n\n\nLennart Justen\n\n\n\n\n\n\n\n\n\n\n\n\nTen-fold serial dilution\n\n\n\n\n\n\npylabrobot\n\n\nopentrons\n\n\ncode\n\n\n\n\n\n\n\n\n\nApr 15, 2024\n\n\nLennart Justen\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome to my lab notebook\n\n\n\n\n\n\n\n\n\n\n\nApr 5, 2024\n\n\nLennart Justen\n\n\n\n\n\n\nNo matching items"
  }
]